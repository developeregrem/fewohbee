<?php

declare(strict_types=1);

namespace App\Repository;

use App\Entity\Appartment;
use App\Entity\CalendarSyncImport;
use App\Entity\Reservation;
use App\Entity\Subsidiary;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\ORM\NoResultException;
use Doctrine\Persistence\ManagerRegistry;

/**
 * ReservationRepository.
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class ReservationRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, Reservation::class);
    }

    public function loadReservationsForPeriod($startDate, $endDate)
    {
        $start = date('Y-m-d', strtotime($startDate));
        $end = date('Y-m-d', strtotime($endDate));

        //        if($customer == null) {
        $q = $this
            ->createQueryBuilder('u')
            ->select('u')
            ->andWhere('((u.startDate >= :start AND u.startDate < :end AND u.endDate > :start AND u.endDate <= :end) OR'
                .'(u.startDate <= :start AND u.endDate > :start AND u.endDate <= :end) OR'
                .'(u.startDate >= :start AND u.startDate < :end AND u.endDate > :end) OR'
                .'(u.startDate <= :start AND u.endDate >= :end))')
            // ->andWhere('u.invoice IS NULL')
            ->setParameter('start', $start)
            ->setParameter('end', $end)
            ->addOrderBy('u.endDate', 'ASC')
            ->getQuery();
        //        } else {
        //            $q = $this
        //                ->createQueryBuilder('u')
        //                ->select('u')
        //                ->andWhere('((u.startDate >= :start AND u.startDate < :end AND u.endDate > :start AND u.endDate <= :end) OR'
        //                         .  '(u.startDate <= :start AND u.endDate > :start AND u.endDate <= :end) OR'
        //                         .  '(u.startDate >= :start AND u.startDate < :end AND u.endDate > :end) OR'
        //                         .  '(u.startDate <= :start AND u.endDate >= :end))')
        //                ->andWhere('u.invoice IS NULL')
        //                ->andWhere('u.booker = :customer')
        //                ->setParameter('start', $start)
        //                ->setParameter('end', $end)
        //                ->setParameter('customer', $customer)
        //                ->addOrderBy('u.endDate', 'ASC')
        //                ->getQuery();
        //        }

        $reservations = null;
        try {
            $reservations = $q->getResult();
        } catch (NoResultException $e) {
        }

        return $reservations;
    }

    /**
     * Load reservations for housekeeping views with required joins and conflict filters.
     *
     * @return Reservation[]
     */
    public function findForHousekeepingRange(
        \DateTimeImmutable $start,
        \DateTimeImmutable $end,
        ?Subsidiary $subsidiary
    ): array {
        $qb = $this->createQueryBuilder('r')
            ->addSelect('a', 'booker', 'customer')
            ->leftJoin('r.appartment', 'a')
            ->leftJoin('r.booker', 'booker')
            ->leftJoin('r.customers', 'customer')
            ->distinct()
            ->andWhere('r.startDate < :end')
            ->andWhere('r.endDate >= :start')
            ->andWhere('r.isConflict = 0')
            ->andWhere('r.isConflictIgnored = 0')
            ->setParameter('start', $start)
            ->setParameter('end', $end)
            ->addOrderBy('r.startDate', 'ASC');

        if ($subsidiary instanceof Subsidiary) {
            $qb->andWhere('a.object = :subsidiary')
                ->setParameter('subsidiary', $subsidiary->getId());
        }

        return $qb->getQuery()->getResult();
    }

    public function supportsClass($class)
    {
        return $this->getEntityName() === $class
        || is_subclass_of($class, $this->getEntityName());
    }

    /**
     * Loads reservations that fits into the period and will include reservations that end at the given start date or starts at the given end date.
     */
    public function loadReservationsForApartment(\DateTimeInterface $start, \DateTimeInterface $end, Appartment $apartment): array
    {
        $q = $this
            ->createQueryBuilder('u')
            ->select('u')
            ->where('u.appartment = :app ')
            ->andWhere('u.isConflict = 0')
            ->andWhere('((u.startDate >= :start AND u.endDate <= :end) OR'
                .'(u.startDate < :start AND u.endDate >= :start) OR'
                .'(u.startDate <= :end AND u.endDate > :end) OR'
                .'(u.startDate < :start AND u.endDate > :end))')
            ->setParameter('start', $start)
            ->setParameter('end', $end)
            ->setParameter('app', $apartment->getId())
            ->addOrderBy('u.endDate', 'ASC')
            ->getQuery();

        $reservations = [];
        try {
            $reservations = $q->getResult();
        } catch (NoResultException $e) {
        }

        return $reservations;
    }

    /**
     * Loads only reservations that fits into the given period. A reservation which ends at the start date or starts at the end date will be ignored.
     */
    public function loadReservationsForApartmentWithoutStartEnd(\DateTimeInterface $start, \DateTimeInterface $end, Appartment $apartment): array
    {
        $q = $this
            ->createQueryBuilder('u')
            ->select('u')
            ->where('u.appartment = :app ')
            ->andWhere('u.isConflict = 0')
            ->andWhere('((u.startDate >= :start AND u.endDate <= :end) OR'
                .'(u.startDate < :start AND u.endDate > :start) OR'
                .'(u.startDate < :end AND u.endDate > :end) OR'
                .'(u.startDate < :start AND u.endDate > :end))')
            ->setParameter('start', $start)
            ->setParameter('end', $end)
            ->setParameter('app', $apartment->getId())
            ->addOrderBy('u.endDate', 'ASC')
            ->getQuery();

        $reservations = [];
        try {
            $reservations = $q->getResult();
        } catch (NoResultException $e) {
        }

        return $reservations;
    }

    public function loadReservationsWithoutInvoiceForCustomer(\App\Entity\Customer $customer)
    {
        $q = $this
            ->createQueryBuilder('u')
            ->select('u')
            ->where('u.booker = :booker')
            // ->andWhere('u.invoice IS NULL')
            ->setParameter('booker', $customer->getId())
            ->addOrderBy('u.endDate', 'ASC')
            ->getQuery();

        $reservations = null;
        try {
            $reservations = $q->getResult();
        } catch (NoResultException $e) {
        }

        return $reservations;
    }

    public function loadUtilizationForDay($day, $objectId)
    {
        if ('all' === $objectId) {
            $query = $this->createQueryBuilder('u')
            ->select('SUM(u.persons)')
            ->where(':day >= u.startDate and :day < u.endDate')
            ->andWhere('u.isConflict = 0')
            ->andWhere('u.isConflictIgnored = 0')
            // ->andWhere('u.status=1')
            // ->addGroupBy('u.persons')
            ->setParameter('day', $day)
            ->getQuery();
        } else {
            $query = $this->createQueryBuilder('u')
            ->select('SUM(u.persons)')
            ->where('a.object = :objId and :day >= u.startDate and :day < u.endDate')
            ->andWhere('u.isConflict = 0')
            ->andWhere('u.isConflictIgnored = 0')
            // ->andWhere('u.status=1')
            ->join('u.appartment', 'a')
            // ->addGroupBy('u.persons')
            ->setParameter('day', $day)
            ->setParameter('objId', $objectId)
            ->getQuery();
        }

        try {
            return $query->getSingleScalarResult();
        } catch (NoResultException $ex) {
            return 0;
        }
    }

    public function getMinEndDate()
    {
        $q = $this
            ->createQueryBuilder('r')
            ->select('MIN(r.endDate)')
            ->getQuery();

        return $q->getSingleScalarResult();
    }

    public function getMaxStartDate()
    {
        $q = $this
            ->createQueryBuilder('r')
            ->select('MAX(r.startDate)')
            ->getQuery();

        return $q->getSingleScalarResult();
    }

    public function loadReservationsForMonth($month, $year, $objectId)
    {
        $startTs = strtotime($year.'-'.$month.'-01');
        $start = date('Y-m-d', $startTs);
        $end = date('Y-m-d', strtotime('+1 month', $startTs));

        $q = $this
            ->createQueryBuilder('u')
            ->select('u')
            ->join('u.appartment', 'a')
            // ->where('u.status=1')
            ->where('u.startDate < :end AND u.endDate > :start')
            ->andWhere('u.isConflict = 0')
            ->andWhere('u.isConflictIgnored = 0')
            ->setParameter('start', $start)
            ->setParameter('end', $end)
            ->addOrderBy('u.endDate', 'ASC');

        if ('all' !== $objectId) {
            $q->andWhere('a.object = :objId')
              ->setParameter('objId', $objectId);
        }

        try {
            return $q->getQuery()->getResult();
        } catch (NoResultException $e) {
            return [];
        }
    }

    public function loadOriginStatisticForPeriod($start, $end, $objectId)
    {
        if ('all' === $objectId) {
            $query = $this->createQueryBuilder('u')
            ->select('ro.id, COUNT(u.id) as origins')
            ->join('u.reservationOrigin', 'ro')
            ->where('u.startDate >= :start and u.endDate <= :end')
            ->andWhere('u.isConflict = 0')
            ->andWhere('u.isConflictIgnored = 0')
            // ->andWhere('u.status=1')
            ->addGroupBy('u.reservationOrigin')
            ->setParameter('start', $start)
            ->setParameter('end', $end)
            ->getQuery();
        } else {
            $query = $this->createQueryBuilder('u')
            ->select('ro.id, COUNT(u.id) as origins')
            ->join('u.reservationOrigin', 'ro')
            ->where('a.object = :objId and u.startDate >= :start and u.endDate <= :end')
            ->andWhere('u.isConflict = 0')
            ->andWhere('u.isConflictIgnored = 0')
            // ->andWhere('u.status=1')
            ->join('u.appartment', 'a')
            ->addGroupBy('u.reservationOrigin')
            ->setParameter('start', $start)
            ->setParameter('end', $end)
            ->setParameter('objId', $objectId)
            ->getQuery();
        }

        try {
            return $query->getArrayResult();
        } catch (NoResultException $ex) {
            return 0;
        }
    }

    /**
     * Load a reservation by import UID and source.
     */
    public function findOneByRefUidAndImport(string $refUid, CalendarSyncImport $import): ?Reservation
    {
        return $this->createQueryBuilder('u')
            ->where('u.refUid = :refUid')
            ->andWhere('u.calendarSyncImport = :import')
            ->setParameter('refUid', $refUid)
            ->setParameter('import', $import)
            ->getQuery()
            ->getOneOrNullResult();
    }

    /**
     * Return active conflict reservations that are not ignored.
     *
     * @return Reservation[]
     */
    public function findActiveConflicts(): array
    {
        return $this->createQueryBuilder('u')
            ->where('u.isConflict = 1')
            ->andWhere('u.isConflictIgnored = 0')
            ->orderBy('u.startDate', 'ASC')
            ->getQuery()
            ->getResult();
    }

    /**
     * Count active conflict reservations that are not ignored.
     */
    public function countActiveConflicts(): int
    {
        return (int) $this->createQueryBuilder('u')
            ->select('COUNT(u.id)')
            ->where('u.isConflict = 1')
            ->andWhere('u.isConflictIgnored = 0')
            ->getQuery()
            ->getSingleScalarResult();
    }

    /**
     * Count imported reservations without a booker that are not conflicts.
     */
    public function countImportedWithoutBooker(): int
    {
        return (int) $this->createQueryBuilder('u')
            ->select('COUNT(u.id)')
            ->where('u.calendarSyncImport IS NOT NULL')
            ->andWhere('u.booker IS NULL')
            ->andWhere('u.isConflict = 0')
            ->getQuery()
            ->getSingleScalarResult();
    }

    /**
     * Return imported reservations without a booker that are not conflicts.
     *
     * @return Reservation[]
     */
    public function findImportedWithoutBookerPaginated(int $page, int $perPage): array
    {
        $offset = max(0, ($page - 1) * $perPage);

        return $this->createQueryBuilder('u')
            ->where('u.calendarSyncImport IS NOT NULL')
            ->andWhere('u.booker IS NULL')
            ->andWhere('u.isConflict = 0')
            ->orderBy('u.startDate', 'ASC')
            ->setFirstResult($offset)
            ->setMaxResults($perPage)
            ->getQuery()
            ->getResult();
    }
}
